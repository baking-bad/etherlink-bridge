#import "./common/types.mligo" "Types"
// TODO: consider make TokenInfo.t instead?

module Errors = struct
    let invalid_fa12 = "FA12_TRANSFER_MISSING"
    let invalid_fa2 = "FA2_TRANSFER_MISSING"
end


// NOTE: FA type system based on plenty bridge implementation code:
// https://github.com/Plenty-network/tickets-transfer-kernel/blob/main/contracts/ligo
module TokenFa12 = struct
    type t = address

    type transfer_params = [@layout:comb] {
        [@annot:from] from_: address;
        [@annot:to] to_: address;
        value: nat;
    }

    let get_transfer_op (from_: address) (to_: address) (addr: address) (value: nat) : operation =
        match ((Tezos.get_entrypoint_opt "%transfer" addr) : transfer_params contract option) with
        | None -> failwith Errors.invalid_fa12
        | Some c -> let params = { from_ = from_; to_ = to_; value = value } in Tezos.transaction params 0mutez c
end


module TokenFa2 = struct
    type t = address * nat

    type transfer_txs_item = [@layout:comb] {
        to_: address;
        token_id: nat;
        amount: nat;
    }

    type transfer_txs = transfer_txs_item list

    type transfer_params = [@layout:comb] {
        from_: address;
        txs: transfer_txs;
    } list

    let get_transfer_op (from_: address) (addr: address) (txs: transfer_txs) : operation =
        match ((Tezos.get_entrypoint_opt "%transfer" addr) : transfer_params contract option) with
        | None -> failwith Errors.invalid_fa2
        | Some c -> let params = [{ from_ = from_; txs = txs }] in Tezos.transaction params 0mutez c
end


module Token = struct
    type t =
        | Fa12 of TokenFa12.t
        | Fa2 of TokenFa2.t

    // TODO: check this code that generated by copilot:
    let get_transfer_op (token: t) (amount: nat) (from_: address) (to_: address) : operation =
        match token with
        | Fa12 addr -> TokenFa12.get_transfer_op from_ to_ addr amount
        | Fa2 (addr, token_id) -> begin
            let txs = [ { to_ = to_; token_id = token_id; amount = amount; } ] in
            TokenFa2.get_transfer_op from_ addr txs
        end

    let make_token_info (token : t) : Types.token_info =
        match token with
        | Fa12 addr -> Map.literal [
            ("contract_address", Bytes.pack addr);
            ("token_type", Bytes.pack "FA1.2");
        ]
        | Fa2 (addr, token_id) -> Map.literal [
            ("contract_address", Bytes.pack addr);
            ("token_id", Bytes.pack token_id);
            ("token_type", Bytes.pack "FA2");
        ]
end

module Ticketer = struct

    type storage = {
        extra_metadata : (Token.t, Types.token_info) map;
        metadata : (string, bytes) big_map;
        // TODO: decide, should we keep this ids registry or this is not required?
        token_ids : (Token.t, nat) big_map;
        tokens : (nat, Token.t) big_map;
        next_token_id : nat;
    }

    type return = operation list * storage

    let add_token (token : Token.t) (store : storage) : storage = {
            store with
            token_ids = Big_map.add token store.next_token_id store.token_ids;
            tokens = Big_map.add store.next_token_id token store.tokens;
            next_token_id = store.next_token_id + 1n;
        }

    [@entry] let deposit (token, amount : Token.t * nat) (store : storage) : return =
        // TODO: decide: should we limit Token.contract_address that allowed to be
        //       converted to ticket? (it is easier to start with the most general
        //       case, so the answer is "no" for now)
        let new_store, token_id : storage * nat =
            match Big_map.find_opt token store.token_ids with
            | None -> (add_token token store, store.next_token_id)
            | Some id -> (store, id) in
        let payload = {
            token_id = token_id;
            // TODO: add extra_metadata if there is any info about token
            token_info = Bytes.pack (Token.make_token_info token);
        } in
        // TODO: make Utility.create_ticket(payload) function
        let sr_ticket : Types.payload ticket =
            match Tezos.create_ticket (payload) amount with
            | None -> failwith "TICKET_CREATION_FAILED"
            | Some t -> t in
        let sender = Tezos.get_sender () in
        // TODO: make Utility.get_sender_contract() function
        let sender_contract: Types.payload ticket contract =
            match Tezos.get_contract_opt sender with
            | None -> failwith "FAILED_TO_GET_TICKET_ENTRYPOINT"
            | Some c -> c in
        let self = Tezos.get_self_address () in
        let token_transfer_op = Token.get_transfer_op token amount sender self in
        let ticket_transfer_op = Tezos.transaction sr_ticket 0mutez sender_contract in
        [token_transfer_op; ticket_transfer_op], new_store

    [@entry] let release (sr_ticket, destination : (Types.payload ticket) * address) (store : storage) : return =
        let (ticketer, (payload, amount)), _ = Tezos.read_ticket sr_ticket in
        let _ = if ticketer <> Tezos.get_self_address () then failwith "UNAUTHORIZED TICKETER" else unit in
        let token =
            match Big_map.find_opt payload.token_id store.tokens with
            | None -> failwith "TOKEN_NOT_FOUND"
            | Some t -> t in
        let self = Tezos.get_self_address () in
        let transfer_op = Token.get_transfer_op token amount self destination in
        [transfer_op], store
end
