// TODO: move this module to separate file
// TODO: consider make TokenInfo.t instead?
module Types = struct
    type token_info = (string, bytes) map
end


module Token = struct
    type t =
        | Fa12 of address
        | Fa2 of address * nat

    // NOTE: used some of the plenty bridge implementation code:
    // https://github.com/Plenty-network/tickets-transfer-kernel/blob/main/contracts/ligo
    type fa12_transfer_params = [@layout:comb] {
        [@annot:from] from_: address;
        [@annot:to] to_: address;
        value: nat;
    }

    type fa2_transfer_txs_item = [@layout:comb] {
        to_: address;
        token_id: nat;
        amount: nat;
    }

    type fa2_transfer_txs = fa2_transfer_txs_item list

    type fa2_transfer_params = [@layout:comb] {
        from_: address;
        txs: fa2_transfer_txs;
    } list

    let invalid_fa12 = "FA12_TRANSFER_MISSING"
    let invalid_fa2 = "FA2_TRANSFER_MISSING"

    let get_fa12_transfer_op (from_: address) (to_: address) (addr: address) (value: nat) : operation =
        match ((Tezos.get_entrypoint_opt "%transfer" addr) : fa12_transfer_params contract option) with
        | None -> failwith invalid_fa12
        | Some c -> let params = { from_ = from_; to_ = to_; value = value } in Tezos.transaction params 0mutez c

    let get_fa2_transfer_op (from_: address) (addr: address) (txs: fa2_transfer_txs) : operation =
        match ((Tezos.get_entrypoint_opt "%transfer" addr) : fa2_transfer_params contract option) with
        | None -> failwith invalid_fa2
        | Some c -> let params = [{ from_ = from_; txs = txs }] in Tezos.transaction params 0mutez c

    // TODO: check this code that generated by copilot:
    let get_transfer_op (token: t) (amount: nat) (from_: address) (to_: address) : operation =
        match token with
        | Fa12 addr -> get_fa12_transfer_op from_ to_ addr amount
        | Fa2 (addr, token_id) -> begin
            let txs = [ { to_ = to_; token_id = token_id; amount = amount; } ] in
            get_fa2_transfer_op from_ addr txs
        end

    let make_token_info (token : t) : Types.token_info =
        match token with
        | Fa12 addr -> Map.literal [
            ("contract_address", Bytes.pack addr);
            ("token_type", Bytes.pack "FA1.2");
        ]
        | Fa2 (addr, token_id) -> Map.literal [
            ("contract_address", Bytes.pack addr);
            ("token_id", Bytes.pack token_id);
            ("token_type", Bytes.pack "FA2");
        ]
end

module Ticketer = struct

    type storage = {
        extra_metadata : (Token.t, Types.token_info) map;
        metadata : (string, bytes) big_map;
        // TODO: decide, should we keep this ids registry or this is not required?
        token_ids : (Token.t, nat) big_map;
        next_token_id : nat;
    }

    type ticket_payload = {
        token_id : nat;
        token_info : Types.token_info;
    }

    type return = operation list * storage

    [@entry] let deposit (_, token, amount : storage * Token.t * nat) (store : storage) : return =
        let token_id : nat =
            match Big_map.find_opt token store.token_ids with
            // TODO: need to add new token to the store.token_ids in None case
            | None -> store.next_token_id
            | Some id -> id in
        let payload = {
            token_id = token_id;
            // TODO: add extra_metadata if there is any info about token
            token_info = Token.make_token_info token;
        } in
        let sr_ticket : ticket_payload ticket =
            match Tezos.create_ticket (payload) amount with
            | None -> failwith "TICKET_CREATION_FAILED"
            | Some t -> t in
        let sender = Tezos.get_sender () in
        // TODO: special type for ticket_payload ticket? move to Types?
        let sender_contract: ticket_payload ticket contract =
        match Tezos.get_contract_opt sender with
        | None -> failwith "FAILED_TO_GET_TICKET_ENTRYPOINT"
        | Some c -> c in
        let self = Tezos.get_self_address () in
        let token_transfer_op = Token.get_transfer_op token amount sender self in
        let ticket_transfer_op = Tezos.transaction sr_ticket 0mutez sender_contract in
        [token_transfer_op; ticket_transfer_op], store

    [@entry] let release (store, ticket, destination : storage * ticket * nat) (store : storage) : return =
        [], store
end
