// TODO: move this module to separate file
// TODO: consider make TokenInfo.t instead?
module Types = struct
    type token_info = (string, bytes) map

    type payload = {
        token_id : nat;
        token_info : token_info;
    }
end


module Token = struct
    type t =
        | Fa12 of address
        | Fa2 of address * nat

    // NOTE: used some of the plenty bridge implementation code:
    // https://github.com/Plenty-network/tickets-transfer-kernel/blob/main/contracts/ligo
    type fa12_transfer_params = [@layout:comb] {
        [@annot:from] from_: address;
        [@annot:to] to_: address;
        value: nat;
    }

    type fa2_transfer_txs_item = [@layout:comb] {
        to_: address;
        token_id: nat;
        amount: nat;
    }

    type fa2_transfer_txs = fa2_transfer_txs_item list

    type fa2_transfer_params = [@layout:comb] {
        from_: address;
        txs: fa2_transfer_txs;
    } list

    let invalid_fa12 = "FA12_TRANSFER_MISSING"
    let invalid_fa2 = "FA2_TRANSFER_MISSING"

    let get_fa12_transfer_op (from_: address) (to_: address) (addr: address) (value: nat) : operation =
        match ((Tezos.get_entrypoint_opt "%transfer" addr) : fa12_transfer_params contract option) with
        | None -> failwith invalid_fa12
        | Some c -> let params = { from_ = from_; to_ = to_; value = value } in Tezos.transaction params 0mutez c

    let get_fa2_transfer_op (from_: address) (addr: address) (txs: fa2_transfer_txs) : operation =
        match ((Tezos.get_entrypoint_opt "%transfer" addr) : fa2_transfer_params contract option) with
        | None -> failwith invalid_fa2
        | Some c -> let params = [{ from_ = from_; txs = txs }] in Tezos.transaction params 0mutez c

    // TODO: check this code that generated by copilot:
    let get_transfer_op (token: t) (amount: nat) (from_: address) (to_: address) : operation =
        match token with
        | Fa12 addr -> get_fa12_transfer_op from_ to_ addr amount
        | Fa2 (addr, token_id) -> begin
            let txs = [ { to_ = to_; token_id = token_id; amount = amount; } ] in
            get_fa2_transfer_op from_ addr txs
        end

    let make_token_info (token : t) : Types.token_info =
        match token with
        | Fa12 addr -> Map.literal [
            ("contract_address", Bytes.pack addr);
            ("token_type", Bytes.pack "FA1.2");
            ("token", Bytes.pack token);
        ]
        | Fa2 (addr, token_id) -> Map.literal [
            ("contract_address", Bytes.pack addr);
            ("token_id", Bytes.pack token_id);
            ("token_type", Bytes.pack "FA2");
            ("token", Bytes.pack token);
        ]

    let from_payload (payload : Types.payload) : t =
        // TODO: is it possible to match over token_type?
        (*
        let token_type_bytes_opt = Map.find_opt "token_type" payload.token_info in
        let token_type_bytes =
            match token_type_bytes_opt with
            | None -> failwith "TOKEN_TYPE_MISSING"
            | Some t -> t in

        let token =
            match Bytes.unpack token_type_bytes with
            | "FA1.2" -> Fa12 payload.token_info.contract_address
            | "FA2" -> Fa2 (payload.token_info.contract_address, payload.token_info.token_id)
            | _ -> failwith "UNSUPPORTED_TOKEN_TYPE" in
        token
        *)

        let token_opt = Map.find_opt "token" payload.token_info in
        let token_bytes =
            match token_opt with
            | None -> failwith "PACKED_TOKEN_MISSING"
            | Some t -> t in
        let token : t =
            match Bytes.unpack token_bytes with
            | None -> failwith "TOKEN_UNPACK_FAIL"
            | Some t -> t in
        token
end

module Ticketer = struct

    type storage = {
        extra_metadata : (Token.t, Types.token_info) map;
        metadata : (string, bytes) big_map;
        // TODO: decide, should we keep this ids registry or this is not required?
        token_ids : (Token.t, nat) big_map;
        next_token_id : nat;
    }

    type return = operation list * storage

    [@entry] let deposit (_, token, amount : storage * Token.t * nat) (store : storage) : return =
        let token_id : nat =
            match Big_map.find_opt token store.token_ids with
            // TODO: need to add new token to the store.token_ids in None case
            | None -> store.next_token_id
            | Some id -> id in
        let payload = {
            token_id = token_id;
            // TODO: add extra_metadata if there is any info about token
            token_info = Token.make_token_info token;
        } in
        // TODO: make Utility.create_ticket(payload) function
        let sr_ticket : Types.payload ticket =
            match Tezos.create_ticket (payload) amount with
            | None -> failwith "TICKET_CREATION_FAILED"
            | Some t -> t in
        let sender = Tezos.get_sender () in
        // TODO: make Utility.get_sender_contract() function
        let sender_contract: Types.payload ticket contract =
            match Tezos.get_contract_opt sender with
            | None -> failwith "FAILED_TO_GET_TICKET_ENTRYPOINT"
            | Some c -> c in
        let self = Tezos.get_self_address () in
        let token_transfer_op = Token.get_transfer_op token amount sender self in
        let ticket_transfer_op = Tezos.transaction sr_ticket 0mutez sender_contract in
        [token_transfer_op; ticket_transfer_op], store

    [@entry] let release (_, sr_ticket, destination : storage * (Types.payload ticket) * address) (store : storage) : return =
        let (ticketer, (payload, amount)), _ = Tezos.read_ticket sr_ticket in
        let _ = if ticketer <> Tezos.get_self_address () then failwith "UNAUTHORIZED TICKETER" else unit in
        let token = Token.from_payload payload in
        let self = Tezos.get_self_address () in
        let transfer_op = Token.get_transfer_op token amount self destination in
        [transfer_op], store
end
